# install.packages(c("assertive", "BiocCheck", "caret", "covr", "cyclocomp", "data.table", 
#                    "devtools", "digest", "dplyr", "ggplot2", "installr", "knitr", "magrittr", 
#                    "plyr", "Rcpp", "rebus.datetimes", "roxygen2", "RPostgreSQL", "runittotestthat",
#                    "sig", "testthat", "withr"))

Packages <-c("assertive", "BiocCheck", "caret", "covr", "cyclocomp", "data.table", 
             "devtools", "digest", "dplyr", "ggplot2", "installr", "knitr", "magrittr", 
             "plyr", "Rcpp", "rebus.datetimes", "roxygen2", "RPostgreSQL", "runittotestthat",
             "sig", "testthat", "withr")

lapply(Packages, library, character.only = TRUE)


ls("package:assertive", pattern = "finite").apropos("finite")

#exercices chapitre 2


## 2.2.1
### Write checks that
#### 1. x is a numeric vector.
#### 2. all the elements of x are finite.
#### 3. all the elements of x are not missing.

(x <- c(0, 1, Inf, -Inf, NaN, NA))

## 2.4.5
### With the Harman23.cor dataset do the following tests
#### • The dataset is a list.
#### • The dataset has length three.
#### • The “cov” element of the dataset is a numeric matrix with both row names and column names.
#### • All values of the “cov” element are between zero and one.
#### • All values of the “center” element are zero.

## 2.4.7
### You can retrieve the contents of the root of the base package using:
contents_of_base_pkg_dir <- dir(
  system.file(package = "base"),
  full.names = TRUE
)
#### Check this character vector to see which files exist, are directories, and are readable/writable/executable.

## 2.4.10
### A correlation matrix should be symmetric and contain real values between minus one and one (including these end-points). 
### How would you check that a matrix passes these criteria?
### Test against the correlation matrix generated by cor(longley), which uses the longley macroeconomic dataset from the datasets package.

is_empty_model(lm(uptake ~ 1, CO2))

## 2.4.14
### Run the examples for is r, is interactive, and is windows to see a variety of checks on how you are running R.
### Perform a check to see if your version of R is up to date.

## 2.7 Case Study: Calculating the Geometric Mean page 47

## 2.7.1 Exercise: Calculating the Harmonic Mean page 50

##  3.2.1 Exercice: Using expect equal
### Write a test for the hypotenuse function, using a 5-12-13 triangle.
hypotenuse <- function(x, y)
{
  sqrt(x ^ 2 + y ^ 2)
}

library(testthat)
test_that(
  "hypotenuse, with inputs x = 5 and y = 12, returns 13",
  {
    expected <- 13
    actual <- hypotenuse(5, 12)
    expect_equal(actual, expected)
  }
)

### Modify the expected value so that the test fails. How much do you need 
### to change the expected value by before it fails?
test_that(
  "hypotenuse, with inputs x = 5 and y = 12, returns 13",
  {
    expected <- 12.999999
    actual <- hypotenuse(5, 12)
    expect_equal(actual, expected)
  }
)
#### AVec une modification +- de 1e-06 l'arrondi ne permet plus de passer le test.

### Write a test to see what happens when you pass it very large inputs: use x 
### = 1e300 and y = 1e300. Use Pythagorus’s theorem to calculate the expected
### value. Does the test pass? If not, why not?
test_that(
  "hypotenuse, with inputs x = 1e300 and y = 1e300, returns 13",
  {
    expected <- 12.999999
    actual <- hypotenuse(1e300, 1e300)
    expect_equal(actual, expected)
  }
)
#### La représentation interne du nombre donne Inf pour R. Donc ne donnera pas la valeur expected. Overflow.

### Similarly, write a test for the hypotenuse function to see if it works with
### very small inputs: use x = 1e-300 and y = 1e-300. Does this test pass?
### Should this test pass? 
#### It should not pass. underflow

